from rest_framework import serializers
from dj_rest_auth.serializers import UserDetailsSerializer, PasswordResetSerializer, PasswordResetConfirmSerializer
from dj_rest_auth.registration.serializers import RegisterSerializer
from allauth.account.forms import ResetPasswordForm as AllAuthPasswordResetForm
from django.utils.http import urlsafe_base64_decode
from django.contrib.auth import get_user_model
from django.contrib.auth.tokens import default_token_generator
from django.utils.encoding import force_str
from django.contrib.auth.password_validation import validate_password

# 1. User Details (for /user/me/)
class CustomUserDetailsSerializer(UserDetailsSerializer):
    role = serializers.CharField(source="profile.role", read_only=True)
    organization_name = serializers.CharField(source="profile.organization.name", read_only=True, allow_null=True)
    is_setup_complete = serializers.BooleanField(source="profile.is_setup_complete", read_only=True)
    permissions = serializers.JSONField(source="profile.permissions", read_only=True)

    class Meta(UserDetailsSerializer.Meta):
        fields = UserDetailsSerializer.Meta.fields + (
            'role', 'organization_name', 'is_setup_complete', 'permissions'
        )

# 2. Password Reset Request (Sending the Email)
class CustomPasswordResetSerializer(PasswordResetSerializer):
    """
    Forces dj-rest-auth to use the AllAuth form. 
    This allows Google users (who have no password) to reset/set one.
    """
    @property
    def password_reset_form_class(self):
        return AllAuthPasswordResetForm

# 3. Password Reset Confirm (Setting the New Password)
class CustomPasswordResetConfirmSerializer(PasswordResetConfirmSerializer):
    """
    Custom validation logic to handle UID/Token checks manually, 
    preventing 'Invalid Value' errors on valid requests.
    """
    def validate(self, attrs):
        # A. Decode UID
        try:
            uid_b64 = attrs.get('uid')
            uid = force_str(urlsafe_base64_decode(uid_b64))
            self.user = get_user_model().objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, get_user_model().DoesNotExist):
            raise serializers.ValidationError({'uid': ['Invalid UID']})

        # B. Check Token
        token = attrs.get('token')
        if not default_token_generator.check_token(self.user, token):
            raise serializers.ValidationError({'token': ['Invalid or expired token']})

        # C. Check Passwords Match
        if attrs.get('new_password1') != attrs.get('new_password2'):
            raise serializers.ValidationError({'new_password1': ['Passwords do not match']})

        # D. Check Password Complexity
        try:
            validate_password(attrs.get('new_password1'), self.user)
        except Exception as e:
            raise serializers.ValidationError({'new_password1': list(e.messages)})

        return attrs

    def save(self):
        self.user.set_password(self.validated_data['new_password1'])
        self.user.save()
        return self.user
    

class CustomRegisterSerializer(RegisterSerializer):
    first_name = serializers.CharField(required=False)
    last_name = serializers.CharField(required=False)
    # If you want to force saving a username even if settings say it's not required:
    username = serializers.CharField(required=False) 

    def custom_signup(self, request, user):
        """
        This method is called after the user is created but before the response is returned.
        We use it to save the extra fields passed from the frontend.
        """
        user.first_name = self.validated_data.get('first_name', '')
        user.last_name = self.validated_data.get('last_name', '')
        
        # If the frontend sent a username, save it. 
        # Otherwise, one might have been auto-generated by AllAuth.
        if self.validated_data.get('username'):
            user.username = self.validated_data.get('username')
            
        user.save()